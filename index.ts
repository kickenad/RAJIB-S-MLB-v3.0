// This is an autogenerated file from Firebase Studio.
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
import { onCall, HttpsError } from 'firebase-functions/v2/https';
import axios from 'axios';
import { defineSecret } from 'firebase-functions/params';
import { DataManager } from './data-management';

const coversApiKey = defineSecret('COVERS_API_KEY');
const liveOddsApiKey = defineSecret('LIVE_ODDS_API_KEY');


// Initialize Firebase Admin SDK
try {
  admin.initializeApp();
} catch (e) {
  console.log('Admin SDK already initialized or error during initialization:', e);
}

const db = admin.firestore();

// Function to save manually parsed odds to Firestore
export const saveParsedOdds = functions.https.onCall(async (data, context) => {
    // Optional: Add auth check to ensure only admins can call this
    // if (!context.auth || !context.auth.token.admin) {
    //     throw new functions.https.HttpsError('permission-denied', 'Must be an administrative user to call this function.');
    // }

    const { oddsData } = data;

    if (!oddsData || !oddsData.id) {
        throw new functions.https.HttpsError('invalid-argument', 'The function must be called with "oddsData" containing an "id".');
    }

    try {
        const docRef = db.collection('parsed_odds').doc(oddsData.id);
        await docRef.set(oddsData, { merge: true });
        return { success: true, message: 'Odds saved successfully', docId: oddsData.id };
    } catch (error) {
        console.error('Error saving to Firestore:', error);
        throw new functions.https.HttpsError('internal', 'Could not save odds to database.');
    }
});


// Function to get all manually parsed odds from Firestore
export const getParsedOdds = functions.https.onCall(async (data, context) => {
    try {
        const snapshot = await db.collection('parsed_odds').get();
        if (snapshot.empty) {
            return [];
        }
        const oddsList = snapshot.docs.map(doc => doc.data());
        return oddsList;
    } catch (error) {
        console.error('Error fetching from Firestore:', error);
        throw new functions.https.HttpsError('internal', 'Could not fetch odds from database.');
    }
});

// Callable function to fetch live odds from a 3rd party API
export const getLiveScrapedOdds = onCall({secrets: [liveOddsApiKey]}, async (request) => {
  const apiKey = liveOddsApiKey.value();
  if (!apiKey) {
    throw new HttpsError('failed-precondition', 'The Odds API key is not configured.');
  }

  const markets = 'h2h,spreads,totals';
  const url = `https://api.the-odds-api.com/v4/sports/baseball_mlb/odds/?regions=us&markets=${markets}&oddsFormat=american&apiKey=${apiKey}`;

  try {
    const response = await axios.get(url);
    return response.data;
  } catch(error: any) {
    console.error('Error fetching live odds from API:', error.response?.data || error.message);
    throw new HttpsError('internal', 'Failed to fetch live odds from the third-party API.');
  }
});


// A simple test function to write to firestore
export const testFirestoreWrite = functions.https.onCall(async (data, context) => {
    const { message } = data;
    if (!message) {
        throw new functions.https.HttpsError('invalid-argument', 'A "message" must be provided.');
    }
    try {
        await db.collection('test_collection').doc('test_doc').set({
            message: message,
            timestamp: admin.firestore.FieldValue.serverTimestamp()
        });
        return { success: true, message: `Message "${message}" written successfully.` };
    } catch (error) {
        console.error("Firestore write test error:", error);
        throw new functions.https.HttpsError('internal', 'Failed to write to Firestore.');
    }
});

// A simple test function to read from firestore
export const testFirestoreRead = functions.https.onCall(async (data, context) => {
    try {
        const doc = await db.collection('test_collection').doc('test_doc').get();
        if (!doc.exists) {
            return { message: 'No message found. Please write one first.' };
        }
        return { message: doc.data()?.message };
    } catch (error) {
        console.error("Firestore read test error:", error);
        throw new functions.https.HttpsError('internal', 'Failed to read from Firestore.');
    }
});


// New Trap Detector function
export const analyzeTrap = functions.https.onCall(async (data, context) => {
    const { gameId, aiPick } = data;

    if (!gameId || !aiPick) {
        throw new functions.https.HttpsError('invalid-argument', 'The function must be called with a "gameId" and "aiPick".');
    }
    
    // In a real app, you would fetch live scraped data here.
    // We will use mock data for this example.
    const mockScrapedData = {
        publicBetsHome: 78, 
        publicBetsAway: 22, 
        lineOpen: '2.2', 
        lineCurrent: '2.1', 
        totalOpen: '8.5', 
        totalCurrent: '9.5'
    };

    // Trap scoring logic
    const reasons = [];
    let score = 0;

    const delta = Math.abs(mockScrapedData.publicBetsHome - mockScrapedData.publicBetsAway);
    if (delta > 30) {
        score += 30;
        reasons.push({ reason: "Public % sharp mismatch", level: "ðŸ”¥ Major" });
    }

    if (parseFloat(mockScrapedData.lineOpen) > parseFloat(mockScrapedData.lineCurrent)) {
        score += 20;
        reasons.push({ reason: "Reverse line movement", level: "ðŸ”¥ Major" });
    }

    if (parseFloat(mockScrapedData.totalCurrent) > 9.5) {
        score += 10;
        reasons.push({ reason: "High total, possible bait", level: "âš ï¸ Medium" });
    }
    
    const trapAnalysis = {
        trapFlagged: score >= 60,
        trapScore: Math.min(score, 100),
        trapReasons: reasons
    };

    return { success: true, gameId, trapAnalysis };
});


// Scheduled function for daily data cleanup
export const dailyDataCleanup = functions.pubsub.schedule('0 4 * * *') // Runs daily at 4:00 AM
    .timeZone('America/New_York') // ET timezone
    .onRun(async (context) => {
        console.log('Running daily data cleanup job...');
        const dataManager = new DataManager();
        try {
            await dataManager.cleanupOldDailyData(7); // Keep last 7 days of data
            console.log('Daily data cleanup job completed successfully.');
            return null;
        } catch (error) {
            console.error('Daily data cleanup job failed:', error);
            // Optionally, you can add error reporting here (e.g., to Slack, email)
            return null;
        }
    });
